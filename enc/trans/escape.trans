#include "transcode_data.h"

static int
fun_so_escape_html_chref(void *statep, const unsigned char *s, size_t l, unsigned char *o)
{
    switch (*s) {
      case '&':
        o[0] = '&';
        o[1] = 'a';
        o[2] = 'm';
        o[3] = 'p';
        o[4] = ';';
        return 5;

      case '<':
        o[0] = '&';
        o[1] = 'l';
        o[2] = 't';
        o[3] = ';';
        return 4;

      case '>':
        o[0] = '&';
        o[1] = 'g';
        o[2] = 't';
        o[3] = ';';
        return 4;

      case '"':
        o[0] = '&';
        o[1] = 'q';
        o[2] = 'u';
        o[3] = 'o';
        o[4] = 't';
        o[5] = ';';
        return 6;

      default:
        rb_bug("unexpected char");
    }
} 
<%
  map_amp = {}
  map_amp["{00-25,27-FF}"] = :nomap
  map_amp["26"] = :func_so
  transcode_generate_node(ActionMap.parse(map_amp), "escape_amp_as_chref")

  map_html_text = {}
  map_html_text["{00-25,27-3B,3D,3F-FF}"] = :nomap
  map_html_text["26"] = :func_so
  map_html_text["3C"] = :func_so
  map_html_text["3E"] = :func_so
  transcode_generate_node(ActionMap.parse(map_html_text), "escape_html_text")

  map_html_attr = {}
  map_html_attr["{00-FF}"] = :func_so
  transcode_generate_node(ActionMap.parse(map_html_attr), "escape_html_attr")
%>

<%= transcode_generated_code %>

static const rb_transcoder
rb_escape_amp_as_chref = {
    "", "amp-escaped", escape_amp_as_chref,
    TRANSCODE_TABLE_INFO,
    1, /* input_unit_length */
    1, /* max_input */
    5, /* max_output */
    stateless_converter, /* stateful_type */
    0, NULL, NULL,
    NULL, NULL, NULL, &fun_so_escape_html_chref
};

static const rb_transcoder
rb_escape_html_text = {
    "", "html-text-escaped", escape_html_text,
    TRANSCODE_TABLE_INFO,
    1, /* input_unit_length */
    1, /* max_input */
    5, /* max_output */
    stateless_converter, /* stateful_type */
    0, NULL, NULL,
    NULL, NULL, NULL, &fun_so_escape_html_chref
};

#define END 0
#define NORMAL  1

static int
escape_html_attr_init(void *statep)
{
    unsigned char *sp = statep;
    *sp = END;
    return 0;
}

static VALUE
fun_so_escape_html_attr(void *statep, const unsigned char *s, size_t l, unsigned char *o)
{
    unsigned char *sp = statep;
    int n = 0;
    if (*sp == END) {
        *sp = NORMAL;
        o[n++] = '"';
    }
    switch (s[0]) {
      case '&':
      case '<':
      case '>':
      case '"':
        n += fun_so_escape_html_chref(statep, s, l, o+n);
        break;

      default:
        o[n++] = s[0];
        break;
    }
    return n;
}

static int
escape_html_attr_finish(void *statep, unsigned char *o)
{
    unsigned char *sp = statep;
    int n = 0;

    if (*sp == END) {
        o[n++] = '"';
    }

    o[n++] = '"';
    *sp = END;

    return n;
}

static const rb_transcoder
rb_escape_html_attr = {
    "", "html-attr-escaped", escape_html_attr,
    TRANSCODE_TABLE_INFO,
    1, /* input_unit_length */
    1, /* max_input */
    7, /* max_output */
    stateful_encoder, /* stateful_type */
    1, escape_html_attr_init, escape_html_attr_init,
    NULL, NULL, NULL, fun_so_escape_html_attr,
    escape_html_attr_finish
};

void
Init_escape(void)
{
    rb_register_transcoder(&rb_escape_amp_as_chref);
    rb_register_transcoder(&rb_escape_html_text);
    rb_register_transcoder(&rb_escape_html_attr);
}

