# $Id$

require 'optparse'

def main
  mode = nil
  ids1src = nil
  ids2src = nil
  template = nil
  output = nil

  parser = @parser = OptionParser.new
  parser.banner = "Usage: #{File.basename($0)} --mode=MODE [--ids1src=PATH] [--ids2src=PATH] [--template=PATH] [--output=PATH]"
  parser.on('--mode=MODE', %"ripper/core eventids1") {|m|
    mode = m
  }
  parser.on('--ids1src=PATH', 'A source file of event-IDs 1 (parse.y).') {|path|
    ids1src = path
  }
  parser.on('--ids2src=PATH', 'A source file of event-IDs 2 (eventids2.c).') {|path|
    ids2src = path
  }
  parser.on('--template=PATH', 'A template file of ripper/core.rb.') {|path|
    template = path
  }
  parser.on('--output=PATH', 'An output file.') {|path|
    output = path
  }
  parser.on('--help', 'Prints this message and quit.') {
    puts parser.help
    exit true
  }
  begin
    parser.parse!
  rescue OptionParser::ParseError => err
    usage err.message
  end
  usage 'no mode given' unless mode
  case mode
  when 'ripper/core'
    usage 'no --ids1src' unless ids1src
    usage 'no --ids2src' unless ids2src
    usage 'no --template' unless template
    ids1 = read_ids1(ids1src)
    ids2 = read_ids2(ids2src)
    diff = ids1.map {|id, *| id} & ids2
    unless diff.empty?
      abort "event crash: #{diff.join(' ')}"
    end
    result = generate_ripper_core(template, ids1, ids2)
  when 'eventids1'
    usage 'no --ids1src' unless ids1src
    result = generate_eventids1(read_ids1(ids1src))
  end
  if output
    File.open(output, 'w') {|f|
      f.write result
    }
  else
    puts result
  end
end

def usage(msg)
  $stderr.puts msg
  $stderr.puts @parser.help
  exit false
end

def generate_ripper_core(template, ids1, ids2)
  str = <<header
# This file is automatically generated from #{File.basename(template)} and parse.y.
# DO NOT MODIFY!!!!!!

header
  File.foreach(template) do |line|
    case line
    when /\A\#include ids1/
      str << ids1.map {|id, arity|
        "    #{id.intern.inspect} => #{arity}"
      }.join(",\n") << "\n"
    when /\A\#include ids2/
      str << ids2.map {|id|
        "    #{id.intern.inspect} => 1"
      }.join(",\n") << "\n"
    when /\A\#include handlers1/
      ids1.each do |id, arity|
        str << $/
        str << "  def on_#{id}#{paramdecl(arity)}" << $/
        str << "    #{arity == 0 ? 'nil' : 'a'}" << $/
        str << "  end" << $/
      end
    when /\A\#include handlers2/
      ids2.each do |id|
        str << $/
        str << "  def on_#{id}(token)" << $/
        str << "    token" << $/
        str << "  end" << $/
      end
    when /\A\#include (.*)/
      raise "unknown operation: #include #{$1}"
    else
      str << line
    end
  end
  str
end

def paramdecl(n)
  return '' if n == 0
  '(' + ('a'..'z').to_a[0, n].join(', ') + ')'
end

def generate_eventids1(ids)
  str = ""
  ids.each do |id, arity|
    str << "static ID ripper_id_#{id};" << $/
  end
  str << $/
  str << 'static void' << $/
  str << 'ripper_init_eventids1()' << $/
  str << '{' << $/
  ids.each do |id, arity|
    str << %Q[    ripper_id_#{id} = rb_intern("on_#{id}");] << $/
  end
  str << '}' << $/
  str
end

def read_ids1(path)
  h = read_ids1_with_locations(path)
  check_arity h
  h.map {|event, list| [event, list.first[1]] }\
      .sort_by {|event, arity| event.to_s }
end

def check_arity(h)
  invalid = false
  h.each do |event, list|
    unless list.map {|line, arity| arity }.uniq.size == 1
      invalid = true
      $stderr.puts "arity crash [event=#{event}]: #{ # "
                     list.map {|line,a| "#{line}:#{a}" }.join(', ')
                   }"           # "
    end
  end
  abort if invalid
end

def read_ids1_with_locations(path)
  h = {}
  File.open(path) {|f|
    f.each do |line|
      next if /\A\#\s*define\s+s?dispatch/ =~ line
      next if /ripper_dispatch/ =~ line
      line.scan(/dispatch(\d)\((\w+)/) do |arity, event|
        (h[event] ||= []).push [f.lineno, arity.to_i]
      end
    end
  }
  h
end

def read_ids2(path)
  File.open(path) {|f|
    return f.read.scan(/ripper_id_(\w+)/).flatten.uniq.sort
  }
end

main
