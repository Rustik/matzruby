# $Id$

require 'stringio'
require 'optparse'

def main
  mode = nil
  ids1src = nil
  ids2src = nil
  template = nil
  output = nil

  parser = @parser = OptionParser.new
  parser.banner = "Usage: #{File.basename($0)} --mode=MODE [--ids1src=PATH] [--ids2src=PATH] [--template=PATH] [--output=PATH]"
  parser.on('--mode=MODE', '"ripper/core" or "eventids1".') {|m|
    mode = m
  }
  parser.on('--ids1src=PATH', 'A source file of event-IDs 1 (parse.y).') {|path|
    ids1src = path
  }
  parser.on('--ids2src=PATH', 'A source file of event-IDs 2 (eventids2.c).') {|path|
    ids2src = path
  }
  parser.on('--template=PATH', 'A template file of ripper/core.rb.') {|path|
    template = path
  }
  parser.on('--output=PATH', 'An output file.') {|path|
    output = path
  }
  parser.on('--help', 'Prints this message and quit.') {
    puts parser.help
    exit 0
  }
  begin
    parser.parse!
  rescue OptionParser::ParseError => err
    usage err.message
  end
  usage 'no mode given' unless mode
  case mode
  when 'ripper/core', 'ripper/core.rb'
    usage 'no --ids1src' unless ids1src
    usage 'no --ids2src' unless ids2src
    usage 'no --template' unless template
    ids1 = read_ids1(ids1src)
    ids2 = read_ids2(ids2src)
    unless (ids1.keys & ids2).empty?
      $stderr.puts "event crash: #{(ids1.keys & ids2).join(' ')}"
      exit 1
    end
    result = generate_ripper_core(template, ids1, ids2)
  when 'eventids1', 'eventids1.c'
    usage 'no --ids1src' unless ids1src
    result = generate_eventids1(read_ids1(ids1src))
  end
  if output
    File.open(output, 'w') {|f|
      f.write result
    }
  else
    puts result
  end
end

def usage(msg)
  $stderr.puts msg
  $stderr.puts @parser.help
  exit 1
end

def generate_ripper_core(template, ids1, ids2)
  f = StringIO.new
  f.print <<header
# This file is automatically generated from #{File.basename(template)} and parse.y.
# DO NOT MODIFY!!!!!!

header
  File.foreach(template) do |line|
    case line
    when /\A\#include ids1/
      comma = ''
      ids1.each do |id, arity|
        f.print comma; comma = ",\n"
        f.print "    #{id.intern.inspect} => #{arity}"
      end
      f.puts
    when /\A\#include ids2/
      comma = ''
      ids2.each do |id|
        f.print comma; comma = ",\n"
        f.print "    #{id.intern.inspect} => 1"
      end
      f.puts
    when /\A\#include handlers1/
      ids1.each do |id, arity|
        f.puts
        f.puts "  def on_#{id}#{paramdecl(arity)}"
        f.puts "    #{arity == 0 ? 'nil' : 'a'}"
        f.puts "  end"
      end
    when /\A\#include handlers2/
      ids2.each do |id|
        f.puts
        f.puts "  def on_#{id}(token)"
        f.puts "    token"
        f.puts "  end"
      end
    when /\A\#include (.*)/
      raise "unknown operation: #include #{$1}"
    else
      f.print line
    end
  end
  f.string
end

def paramdecl(n)
  return '' if n == 0
  '(' + ('a'..'z').to_a[0, n].join(', ') + ')'
end

def generate_eventids1(ids)
  f = StringIO.new
  ids.each do |id, arity|
    f.puts "static ID ripper_id_#{id};"
  end
  f.puts
  f.puts 'static void'
  f.puts 'ripper_init_eventids1()'
  f.puts '{'
  ids.each do |id, arity|
    f.puts %Q[    ripper_id_#{id} = rb_intern("on_#{id}");]
  end
  f.puts '}'
  f.string
end

def read_ids1(path)
  h = read_ids1_with_locations(path)
  check_arity h
  h.map {|event, list| [event, list.first[1]] }\
      .sort_by {|event, arity| event.to_s }
end

def check_arity(h)
  invalid = false
  h.each do |event, list|
    unless list.map {|line, arity| arity }.uniq.size == 1
      invalid = true
      $stderr.puts "arity crash [event=#{event}]: #{
                     list.map {|line,a| "#{line}:#{a}" }.join(', ')
                   }"
    end
  end
  exit 1 if invalid
end

def read_ids1_with_locations(path)
  h = {}
  File.open(path) {|f|
    f.each do |line|
      next if /\A\#\s*define\s+s?dispatch/ =~ line
      next if /ripper_dispatch/ =~ line
      line.scan(/dispatch(\d)\((\w+)/) do |arity, event|
        (h[event] ||= []).push [f.lineno, arity]
      end
    end
  }
  h
end

def read_ids2(path)
  File.open(path) {|f|
    return f.read.scan(/ripper_id_(\w+)/).flatten.uniq.sort
  }
end

main
